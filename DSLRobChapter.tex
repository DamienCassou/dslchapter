\documentclass[jou]{apa}
%% More information about the APA style are available here: ftp://ftp.comp.hkbu.edu.hk/pub/TeX/CTAN/macros/latex/contrib/apa/apacls.html

\title{Trends in Domain-Specific Languages for Robotics System}
\fourauthors{Damien Cassou}{Christian Schlegel}{Ulrik P. Schultz}{Serge Stinckwich}
\fouraffiliations{HPI, University of Postdam, Germany}{Hochschule Ulm, Germany}{University of Southern Denmark, Denmark}{UMMISCO, UMI 209\\IRD/IFI/Vietnam National University}

\abstract{The abstract should be here.}

\acknowledgements{Bla bla ...}

\shorttitle{Trends in DSL for Robotics System}
\rightheader{Trends in DSL for Robotics System}
\leftheader{D.\ Cassou, C.\ Schlegel, U.\ Schultz, S.\ Stinckwich}

\begin{document}
\maketitle
One of the dreams of humanity since the ancient time is to be able to create machines that are skilled and intelligent.
This dream is becoming true with robotics\cite{SpringerHandbook:2008fk} which has made unquestionable progresses in the last decades.
Robotics are already making a considerable impact in everyday life from industrial manufacturing to health care, transportation, and exploration of unsafe environments for humans like deep space or nuclear plants.
Tomorrow, robots are envisioned to be as pervasive as today’s personal computer. The improvements in energy storage now allow a simple and light battery to power demanding sensors and actuators for hours. The availability of inexpensive and highly integrated embedded application processors, a consequence of the massive market of mobile phones and game devices like Microsoft’s Kinect, has brought advanced capabilities to mobile robots, such as high-resolution vision. Moreover, the improvements in electronics and hardware have lowered the cost of sensors and actuators, and have improved their quality and reliability. The combination of all these advances has thus led to affordable robot hardware and allowed sophisticated control software.

Despite all these advances, robotics systems are still difficult to design and deploy. This originates from the fact that robotics systems need to control diverse sensors and actuators in real time mode, in the face of significant uncertainty and noise. These systems must achieve their tasks while monitoring for, and reacting to, unanticipated situations. Doing all this concurrently and asynchronously adds immensely to system complexity. Adding to this complexity, robotics systems are often embedded in resource-constraint systems which are difficult to program because of lacking suitable tools and abstractions. Indeed, most of the available tools are quite low-level (C-like). Finally, all robotics systems contain orthogonal variabilities that further add to the overall complexity. For example, moving a robot can be done through either a differential or omnidirectional drive depending on the embedded hardware, and a robot’s temporal scope can range from a millisecond for feedback control to hours for mapping an environment.

This complexity makes robotics system software difficult to adapt and reuse in the context of different robots and scenarios. As a result, commercial robotics systems and research prototypes have either been limited to trivial tasks, such as obstacle detection, or have been restricted to certain kinds of tasks, hardware, or environment. Several software engineering approaches have been proposed to lower the complexity of robotics systems [2]. These approaches include robotics software frameworks (e.g., CLARATy robotic software framework\footnote{\url{http://claraty.jpl.nasa.gov/man/overview/index.php}}), robotics middleware systems (e.g., ROS\footnote{\url{http://www.ros.org/}}), component-based software engineering for robotics\cite{Brugali:2007oq} and model-driven software engineering for Robotics (e.g., OMG RTC\footnote{OMG RTC. Robotic Technology Component (RTC) Specification 1.0, 2008. \url{http://www.omg.org/spec/RTC}}, SmartSoft [10]). All these approaches apply and tailor general-purpose and established principles of lowering complexity to robotics needs and come up with domain-specific extensions.

Domain-Specific Languages (DSLs)\cite{Deursen:2000uq} and Model-Driven Architecture are emerging areas of interest in the robotics research community (see also the recent workshops on these topics [4], [7]). Both have been instrumental for resolving complex issues in a wide range of domains, including distributed and modular robotics, control, and vision. A DSL is a language dedicated to a particular problem domain offering specific notations and abstractions to increase developers productivity and collaboration. Models offer high-level ways for developers to specify the functionality of their system at the right level of abstraction. Robotics systems blend hardware and software in a way that raises many crosscutting concerns that general-purpose programming languages have traditionally had problems with. DSLs and models offer a powerful and systematic way to overcome this problem, enabling the programmer to quickly and precisely implement novel software solutions to complex problems within the robotics domain.

The main purpose of this chapter is to understand why domain-specific languages are interesting in the context of robotics. We will first identify existing DSLs in the robotics community (organized around the main concerns of robotics as listed in \cite{SpringerHandbook:2008fk}). We will then describe some features of DSLs that are particularly useful for the robotics domain such as run-time changes [6] and multiple-DSL integration [4]. We underpin these by robotics examples like URDF (descriptions of robot physical structures\footnote{\url{http://www.ros.org/wiki/urdf}}), task coordination [11], and model-driven software development for robotics (SmartSoft\footnote{\url{http://smart-robotics.sf.net/}}). Finally we will outline some research perspectives in this domain.

\section{Existing Robotics Domain-Specific Languages} % (fold)
\label{sec:Existing_Robotics_Domain-Specific_Languages}
We will first identify existing DSLs in the robotics community (organized around the main concerns of robotics as listed in \cite{SpringerHandbook:2008fk}).
\subsection{Robot Physical Structures and kinematics}
Part B "Robot Structures" of Springer Handbook of Robotics.

\subsubsection{Unified Robot Description Format (URDF)\footnote{\url{http://www.ros.org/wiki/urdf}}}
XML format to represent robot model (Kinematic and dynamic description, visual representation, collision model).
A robot description is usually composed by a set of links elements and a set of joint elements.
ROS contains an URDF parser that allows to build a C++ model from an XML file.
xacro is an XML macro-language suitable to build large URDF files.

\subsubsection{Paper\cite{Brugali:2007uq}}
\subsubsection{Paper\cite{Frigerio:2011fk}}

\input{ArchitectureAndControl.tex}
\subsection{Sensing and perception}
Uncertainty, probabilistic robotics: Lambda0, \cite{Thrun:2000}
\subsection{Visualisation and simulation}
Player-Stage configuration files\cite{Collett:2005bq}
\subsection{Distributed and networked robotics}
\begin{itemize}
\item MDL (Motion Description Language): \cite{Martin:2008vn}, \cite{Martin:2010uq}
\item PRONTO (spatial computing): \cite{Bachrach:2008bs}
\item cooperative robotics: \cite{Welborn:2005dg}
\item reconfigurable robotics: \cite{Schultz:2007le}, \cite{Schultz:2008vl}
\end{itemize}
\subsection{Planning}
\begin{itemize}
\item PDDL (Planning Domain Definition Language)
\item Smach\footnote{\url{http://www.ros.org/wiki/smach}} (finite state machines)
\end{itemize}

\subsection{SmartTCL}

{\sc SmartTCL} \cite{schlegel-smarttcl} is a task coordination language for robotics. Task 
coordination is needed in robotics to manage the huge amount of execution variants occuring 
due to open-ended environments. {\sc SmartTCL} supports hierarchical task representations.
At run-time, a task-tree is dynamically created and modified depending on situation and
context. It comprises three constructs: \mbox{(i) {\em Task Coordination Blocks (TCB)}},
\mbox{(ii) {\em rules}} for contingency handling and \mbox{(iii) {\em event-handler}}
which are associated to events. Each construct comprises an action plot which contains
the business logic.

{\sc SmartTCL} performs dynamic online reconfigurations of the software components of
a robot system. It exploits the configuration, parameterization and dynamic wiring 
capabilities of components as provided by the {\sc SmartSoft} component model.
{\sc SmartTCL} provides event-driven task execution (discrete states) and provides
the bridge to continuous processing in robotics components (e.g. motion control, path
planning).

Designed as a domain-specific language, {\sc SmartTCL} makes it for system integrators 
as simple as possible to execute, arrange and reuse behavior building blocks: \mbox{(i) new}
task plots can be composed out of existing ones based on hierarchical, sequential and parallel 
orderings (preserving a black-box view on a task block without requiring to inspect its internal
and further decompositions and refinements), \mbox{(ii) configurations} required to execute
basic behaviors and tasks can easily be expressed (hiding the complexity of putting them into 
operation, monitoring all the involved software components and properly reacting to asynchronous
events). 

In its current implementation, {\sc SmartTCL} is an internal DSL within LISP. This way, it
exploits the dynamic features of the LISP language (runtime interpretation of at runtime generated
task-net expansions). It also exploits the general purpose language constructs in the implementation
of action plots. {\sc SmartTCL} is being used in scenarios like {\em cleaning up the table},
{\em Robocup@Home} and {\em make coffee}.

\subsection{SmartSoft}

{\sc SmartSoft} \cite{schlegel-jars, schlegel-star} is a service-oriented 
component-based approach. Its component model is represented as meta-model 
called {\sc SmartMARS} \cite{Schlegel2009}. This meta-model is the basis for 
the Eclipse-based {\sc SmartMDSD} model-driven software development toolchain
\footnote{http://smart-robotics.sf.net}.

The basic idea behind {\sc SmartSoft} is to master the component hull. The {\sc SmartSoft} 
component model provides a small and fixed set of communication patterns out of which all 
externally visible ports of a component are composed. The communication patterns cover 
request/response as well as publish/subscribe interactions. They can be customized by 
the type of data to be transmitted but always behave according to the predefined semantics
independently of the chosen implementational technology (e.g. the underlying middleware). 
Besides user-definable ports, the {\sc SmartSoft} component model comprises standardized 
ports for the configuration of a component, dynamic wiring of its ports, introspection of 
components for diagnostic purposes and a port for activation / deactivation of its component 
services.

{\sc SmartSoft} addresses {\em separation of roles} (framework builder, component builder, 
system integrator, end user) as well as {\em separation of concerns} (computation, communication,
configuration, coordination) in robotics. Mastering the component hull allows a clear separation 
e.g. between the roles of a component developer (inside view of a component) and a system integrator 
(black box view on a component). Using a MDSD-approach enforces these roles and provides stable 
interfaces independently of the used implementational technology. Separation of roles is important 
towards reuse of software building blocks in robotics and towards sharing efforts according to 
standard role models as can be found in any successful market. Separation of concerns is important
to decouple orthogonal aspects, e.g. be able to replace a certain middleware by another one better
matching the specifc needs.

\subsection{SMACH}

SMACH \cite{Smach:2011ys} aims to rapidly compose complex robot behaviors out of primitive ones. It is based on the concept of hierarchical concurrent state machines. SMACH is implemented as a language extension of {\em Python} and integrated into {\em ROS} \cite{ros}. It focuses on rapid prototyping of robot behaviors and is, for example, used in the {\em PR2} robot as task coordinatior for scenarios like playing pool and fetching beer from a refridgerator. SMACH executions can be graphically visualized. 

The state machine of SMACH is not event-driven. Instead, each state comprises an action-plot which executed until it  terminates with a return-message. Depending on that message, transitions into next states are performed. SMACH can be seen as a DSL which provides that particular variant of a state machine for robotics users.

\subsection{V$^3$CMM}

The 3-View Component Meta-Model (V$^3$CMM) \cite{JOSER10} aims to provide designers with an expressive 
yet simple platform-independent modeling language for component-based application design. The main design 
drivers behind V$^3$CMM are simplicity, economy of concepts, and component reuse. V$^3$CMM is aimed at 
allowing designers (1) to model high-level reusable components, including both their structural and 
behavioral facets (modeling for reuse); (2) to build complex platform-independent designs up from the 
previous components (modeling by reuse); and (3) to automatically translate these high-level designs 
into lower level models or into different implementations, isolating functionality from platform  details. 
It is worth noting that, although V$^3$CMM contains no robotics (neither other domain) specific concepts, 
it has been tested and used mainly in robotics and in a few other (somehow affine) domains such as 
Wireless Sensors and Actuators Networks (WSAN) \cite{IJCIS07} or Home Automation Systems \cite{IEEESoftware09}. 
Currently, V$^3$CMM is being extended to enable the specification of real-time constraints. Regarding the 
tools supporting V$^3$CMM, new textual model editors with advanced model validation and syntax completion 
facilities are being developed, as well as new model transformations addressing different target implementation 
frameworks. In parallel, there is some work in progress heading towards achieving V$^3$CMM model execution 
(or runtime interpretation), as an alternative to translation into executable code \cite{ROSYM10}.

% section Existing_Robotics_Domain-Specific_Languages (end)

\bibliography{DSLRobChapter}

\end{document}
